{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Osipi Documentation","text":"<p>Welcome to the Osipi documentation! This guide is intended to help you get started with Osipi and provide the information you need to maximize its potential.</p>"},{"location":"#warning","title":"Warning","text":"<p>Warning</p> <p><code>osipi</code> is developed in public but is a work in progress. This version contains mostly temporary placeholder functionality.</p>"},{"location":"#about-osipi","title":"About Osipi","text":"<p><code>osipi</code> is the authoritative Python package for perfusion MRI. It is developed by the Open Source Initiative for Perfusion Imaging (OSIPI), which is a study group initiative of the International Society for Magnetic Resonance in Medicine (ISMRM).</p>"},{"location":"#purpose","title":"Purpose","text":"<p>The purpose of <code>osipi</code> is to standardize and streamline the use of perfusion MRI, ensuring consistency and reliability across different implementations and studies. The package follows the lexicon defined by OSIPI and integrates selected implementations from the original code contributions made by the OSIPI community.</p> <p>Explore the documentation to learn more about how to use <code>osipi</code> and leverage its full capabilities for your perfusion MRI projects.</p>"},{"location":"#sections","title":"Sections","text":"<ul> <li>User Guide</li> <li>Contribution Guidelines</li> <li>References</li> <li>About</li> <li>Examples</li> </ul>"},{"location":"about/","title":"About","text":"<p>The osipi Library is developed by the Open Source Initiative for Perfusion Imaging (OSIPI), an initiative of the perfusion study group of the International Society for Magnetic Resonance in Medicine (ISMRM).</p> <p>The osipi package structure and logic follow the lexicon defined by OSIPI, and wrap around selected implementations collected in the code contributions of OSIPI.</p>"},{"location":"about/#scope","title":"Scope","text":"<p>osipi currently only includes methods for the dynamic contrast (DC) approach to perfusion MRI (DC-MRI, a unifying term for the separate fields DCE-MRI and DSC-MRI). In particular, arterial spin labelling (ASL) solutions are not currently included, but this may change in the future.</p> <p>Future Updates</p> <p>The inclusion of arterial spin labelling (ASL) solutions may change in the future.</p>"},{"location":"contribution/","title":"Developer Guide","text":"<p>There are multiple ways to contribute to <code>osipi</code> and we welcome them all. <code>osipi</code> is a tool developed by the research community for the research community, and we are all responsible for ensuring it is as good as it can be. So, if you feel some part of it is not, fix it!</p> <p>The way to do this is by making a pull request on GitHub. If you are not familiar with GitHub pull requests, it is not as scary as it sounds. The simplest way is to find the file that you want to edit on GitHub in your browser, edit it manually and follow the prompts to create a fork and pull request.</p>"},{"location":"contribution/#making-a-pull-request-pr-to-the-osipi-package","title":"Making a Pull Request (PR) to the OSIPI Package","text":""},{"location":"contribution/#step-1-fork-the-repository","title":"Step 1: Fork the Repository","text":"<p>First, fork the OSIPI repository to your GitHub account and make a new branch with the your new feature or bug fix.</p>"},{"location":"contribution/#step-2-set-up-your-development-environment","title":"Step 2: Set Up Your Development Environment","text":"<p>After creating a fork, you have two options:</p>"},{"location":"contribution/#option-1-use-poetry","title":"Option 1: Use Poetry","text":"<ol> <li>Install Poetry: If you don't have Poetry installed, follow the instructions here.</li> <li>Install Dependencies: Run the following command in your terminal:     <pre><code>poetry install\n</code></pre></li> </ol>"},{"location":"contribution/#option-2-use-requirements-file","title":"Option 2: Use Requirements File","text":"<ol> <li>Install Dependencies: Run the following command in your terminal:     <pre><code>pip install -r requirements.txt\n</code></pre></li> </ol>"},{"location":"contribution/#step-3-make-your-contribution","title":"Step 3: Make Your Contribution","text":"<p>Make your changes or add your contribution to the codebase.</p>"},{"location":"contribution/#step-4-run-pre-commit-checks","title":"Step 4: Run Pre-commit Checks","text":"<p>Before pushing your changes, run pre-commit checks to ensure your code meets the project's standards.</p> <ol> <li>Run the following command in your terminal:     <pre><code>pre-commit run --all-files\n</code></pre></li> </ol>"},{"location":"contribution/#step-5-push-your-changes-and-create-a-pr","title":"Step 5: Push Your Changes and Create a PR","text":"<ol> <li>Push your changes to your forked repository.</li> <li>Create a pull request (PR) to the main OSIPI repository.</li> </ol>"},{"location":"contribution/#how-to-contribute-examples","title":"How to Contribute Examples","text":"<p>One way to contribute is by providing examples of how you used <code>osipi</code> for a specific task. These are usually real-world examples with a relevant aim, perhaps to derive some results that you have published. To package these up as an example, follow these steps:</p> <ol> <li>Code up your example in a single Python file in a narrative style, similar to a notebook. Have a look at the current examples to see how these need to be formatted, especially their docstrings, to make sure they show up properly on the website.</li> <li>When you save your file, make sure the filename starts with plot_.</li> <li>Then drop your file in the examples folder <code>osipi-docs-examples</code> in the appropriate subfolder.</li> </ol> <p>When the documentation is generated, your example will automatically appear in the examples gallery and also in the documentation of any function you are using in the example.</p>"},{"location":"contribution/#how-to-contribute-documentation","title":"How to Contribute Documentation","text":"<p><code>osipi</code> is a user interface and for that reason good, clear and well-structured documentation is equally important as the quality of the functionality itself. We especially welcome suggestions for improving the documentation from end-users who are not necessarily contributing new code. You know best what works, and what doesn't.</p> <p>If you are a user of <code>osipi</code>, and some part of the documentation is not as clear as it can be, then submit your suggestions for improvement and make sure that the next person will not have to face the same issues.</p> <p>If you want to edit the documentation of a specific function, then you need to find the function in the osipi source code <code>osipi-src</code>. Find the function and edit the documentation string immediately below its definition. If you want to edit any other part of the documentation, find the appropriate file in the documentation source code <code>osipi-docs-source</code> and edit it there.</p>"},{"location":"contribution/#how-to-contribute-tests","title":"How to Contribute Tests","text":"<p>Beyond documentation and functionality, solid testing is equally critical for ensuring long-term stability of a package. <code>osipi</code> uses a continuous integration model where all tests are run before each push to the central repository. This is important because often changes at one part of the code, even if tested well locally, can have unintended consequences at other parts. The testing prevents that these errors propagate and destabilize parts of the package.</p> <p>If you find a bug in any part of the code, this obviously points to a flaw in the code, but it also reveals a gap in the testing. It is critical when this happens that both the code AND the tests are reviewed to ensure that in future a scenario of this type is picked up during testing.</p> <p>The tests are defined in the folder <code>osipi-tests</code>.</p>"},{"location":"contribution/#how-to-contribute-functionality","title":"How to Contribute Functionality","text":"<p>OSIPI is always happy to receive new functionality for inclusion in the <code>osipi</code> package. This can be code that addresses a gap in the current functionality, or it can be code that improves the performance of a current implementation. Improvements can consist of extending the functionality (e.g. with new optional arguments), user friendliness or consistency, improvement of the accuracy or precision in the results, computation time, or platform independence, or improved documentation or code structure.</p> <p>Contribution of functionality generally proceeds in two steps. In the first step you submit your code to the primary contributions repository as explained in its wiki. The task force will catalogue your code in the contributions repository and test it as explained in the guidance. Afterwards, if it is found to address a gap in <code>osipi</code> and/or improve existing functionality, you will be invited to submit a pull request to <code>osipi</code> containing your contribution formatted as required by the package.</p> <p>While this is the general process, we accept there may be situations where a new submission to the contributions repository is overkill, for instance if your improvement concerns documentation only, or improvements in code structure or style. In that case a direct pull request to <code>osipi</code> may be acceptable - when in doubt please contact the OSIPI repository lead in the first instance to avoid unnecessary work.</p> <p>See the section on design principles below for general requirements from <code>osipi</code> code snippets.</p>"},{"location":"contribution/#how-to-contribute-issues","title":"How to Contribute Issues","text":"<p>If you have a constructive suggestion for how <code>osipi</code> can be improved, but you are not able to address it yourself for some reason, it is still extremely helpful if you write this up as an issue so it can be picked up by others at a later stage. To write up an issue, go to the <code>osipi</code> repository on GitHub, select <code>issues</code> and write a new one. Make sure to provide sufficient detail so that others can understand and address the issue.</p>"},{"location":"contribution/#design-principles","title":"Design Principles","text":""},{"location":"contribution/#style-guide","title":"Style Guide","text":"<p><code>osipi</code> follows the Google Python Style Guide. This means especially also that we expect proper attention to error handling. Consider for instance what happens if a user calls your snippet using arguments of incorrect type or length. Will they get an appropriate error message that will help them identify and fix the error?</p>"},{"location":"contribution/#package-structure","title":"Package Structure","text":"<p>The <code>osipi</code> documentation follows the structure of the OSIPI Lexicon exactly - see here for a detailed description of the Lexicon.</p> <p>From a user perspective, the package structure is a flat list of functions that can all be accessed as <code>osipi.some_function</code>. They are listed in the init file of the package, directly under the folder <code>src\\osipi</code>. For clarity, the code itself is organized into modules, but these may evolve over time and should not be accessed directly. Module names all start with an underscore <code>_module.py</code> to emphasize their private and transient nature. Equally, subfolders may be added in the future as the package grows.</p>"},{"location":"contribution/#code-snippets","title":"Code Snippets","text":"<p><code>osipi</code> is a collection of simple code snippets following a simple functional programming paradigm (did you see how we said simple twice there?). Each code snippet is a Python function that takes OSIPI variables as arguments and returns other OSIPI variables as results. At this stage, we are not planning to include an object-oriented interface or internal logic as this reduces the modularity of the code snippets, reduces compatibility with other packages, and increases the overhead of learning how to use <code>osipi</code>. Therefore, all code contributions will essentially consist of a new function or an improvement of an existing function.</p> <p>Beyond the general requirements of the Google Python Style Guide, <code>osipi</code> requires that each new function is accompanied by an appropriate test in the tests folder, and that each function fully conforms to the Lexicon. In particular:</p> <ol> <li>Each function must be defined in the lexicon, and the docstring must include a reference section containing the following four items:<ul> <li>Lexicon URL: webpage in the Lexicon where the function is defined.</li> <li>Lexicon code: machine-readable code identifying the entry in the Lexicon.</li> <li>OSIPI name: human-readable name for the function as defined in the Lexicon.</li> <li>Adapted from contribution: module.py in the original snippet in the code contribution repository</li> </ul> </li> <li>Each argument to the function as well as each return value must be defined in the Lexicon. The docstring of the function must provide the following data on each argument and return value:<ul> <li>Python data type (include type hint in the function definition)</li> <li>Lexicon code: machine-readable code identifying the corresponding quantity in the Lexicon.</li> <li>OSIPI name: human-readable name for the quantity as defined in the Lexicon.</li> </ul> </li> <li>All arguments and return values must be provided in OSIPI units as defined in the Lexicon.</li> <li>Arguments should be provided using OSIPI notation as defined in the Lexicon.</li> <li>The docstring of the function must contain a self-contained code example that runs the function and illustrates the output.</li> </ol> <p>Note</p> <p>If your function addresses entirely novel functionality or uses new variables that are not yet described in the Lexicon, then you should first contact the Lexicon maintainers and request that it is added as an entry to the Lexicon. Only afterwards can it be considered as a contribution to the <code>osipi</code> package.</p> <p>Note</p> <p>The original library for code contributions is less stringent as to code structure and documentation or testing requirements. However, it is nevertheless advisable to adhere to the same guidelines when submitting code to the original contributions repository as this will make it easier for testers to understand and run your code, and it will reduce the overhead on your part in rewriting the code</p>"},{"location":"generated/gallery/","title":"Examples","text":""},{"location":"generated/gallery/#examples","title":"Examples","text":""},{"location":"generated/gallery/#illustrating-common-use-cases-of-osipi","title":"Illustrating common use cases of osipi.","text":"<p>Arterial Input Functions</p> <p> A dummy script </p> <p> The Parker AIF - a play with variables </p> <p>Tissue concentrations</p> <p> The Tofts model </p> <p> The Extended Tofts model </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/aif/mg_execution_times/","title":"Computation times","text":"<p>00:00.881 total execution time for generated_gallery_aif files:</p> <p>+--------------------------------------------------------------------------------+-----------+--------+ | plot_dummy (docs/examples/aif/plot_dummy.py)                | 00:00.708 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+ | plot_aif_parker (docs/examples/aif/plot_aif_parker.py) | 00:00.174 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/aif/plot_aif_parker/","title":"The Parker AIF - a play with variables","text":"<p>Note</p> <p>Click here to download the full example code</p> <p>====================================== The Parker AIF - a play with variables ======================================</p> <p>Simulating a Parker AIF with different settings.</p> <pre><code>import matplotlib.pyplot as plt\n</code></pre> <p>Import necessary packages</p> <pre><code>import numpy as np\nimport osipi\n</code></pre> <p>Generate synthetic AIF with default settings and plot the result.</p> <pre><code># Define time points in units of seconds - in this case we use a time\n# resolution of 0.5 sec and a total duration of 6 minutes.\nt = np.arange(0, 6 * 60, 0.5)\n\n# Create an AIF with default settings\nca = osipi.aif_parker(t)\n\n# Plot the AIF over the full range\nplt.plot(t, ca, \"r-\")\nplt.plot(t, 0 * t, \"k-\")\nplt.xlabel(\"Time (sec)\")\nplt.ylabel(\"Plasma concentration (mM)\")\nplt.show()\n</code></pre> <p></p> <p>The bolus arrival time (BAT) defaults to 0s. What happens if we change it? Let's try, by changing it in steps of 30s:</p> <pre><code>ca = osipi.aif_parker(t, BAT=0)\nplt.plot(t, ca, \"b-\", label=\"BAT = 0s\")\nca = osipi.aif_parker(t, BAT=30)\nplt.plot(t, ca, \"r-\", label=\"BAT = 30s\")\nca = osipi.aif_parker(t, BAT=60)\nplt.plot(t, ca, \"g-\", label=\"BAT = 60s\")\nca = osipi.aif_parker(t, BAT=90)\nplt.plot(t, ca, \"m-\", label=\"BAT = 90s\")\nplt.xlabel(\"Time (sec)\")\nplt.ylabel(\"Plasma concentration (mM)\")\nplt.legend()\nplt.show()\n\n# Choose the last image as a thumbnail for the gallery\n# sphinx_gallery_thumbnail_number = -1\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.174 seconds)</p> <p> Download Python source code: plot_aif_parker.py</p> <p> Download Jupyter notebook: plot_aif_parker.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/aif/plot_dummy/","title":"A dummy script","text":"<p>Note</p> <p>Click here to download the full example code</p> <p>============== A dummy script ==============</p> <p>Dummy script to illustrate structure of examples folder</p> <pre><code>import matplotlib.pyplot as plt\n</code></pre> <p>Import necessary packages</p> <pre><code>import numpy as np\nimport osipi\n</code></pre> <p>Generate synthetic AIF with default settings and plot the result.</p> <pre><code># Define time points in units of seconds - in this case we use a time\n# resolution of 0.5 sec and a total duration of 6 minutes.\nt = np.arange(0, 6 * 60, 0.5)\n\n# Create an AIF with default settings\nca = osipi.aif_parker(t)\n\n# Plot the AIF over the full range\nplt.plot(t, ca, \"r-\")\nplt.plot(t, 0 * t, \"k-\")\nplt.xlabel(\"Time (sec)\")\nplt.ylabel(\"Plasma concentration (mM)\")\nplt.show()\n</code></pre> <p></p> <p>The bolus arrival time (BAT) defaults to 30s. What happens if we change it? Let's try, by changing it in steps of 30s:</p> <pre><code>ca = osipi.aif_parker(t, BAT=0)\nplt.plot(t, ca, \"b-\", label=\"BAT = 0s\")\nca = osipi.aif_parker(t, BAT=30)\nplt.plot(t, ca, \"r-\", label=\"BAT = 30s\")\nca = osipi.aif_parker(t, BAT=60)\nplt.plot(t, ca, \"g-\", label=\"BAT = 60s\")\nca = osipi.aif_parker(t, BAT=90)\nplt.plot(t, ca, \"m-\", label=\"BAT = 90s\")\nplt.xlabel(\"Time (sec)\")\nplt.ylabel(\"Plasma concentration (mM)\")\nplt.legend()\nplt.show()\n\n# Choose the last image as a thumbnail for the gallery\n# sphinx_gallery_thumbnail_number = -1\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.708 seconds)</p> <p> Download Python source code: plot_dummy.py</p> <p> Download Jupyter notebook: plot_dummy.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tissue/mg_execution_times/","title":"Computation times","text":"<p>00:00.401 total execution time for generated_gallery_tissue files:</p> <p>+-----------------------------------------------------------------------------------------------+-----------+--------+ | plot_tofts (docs/examples/tissue/plot_tofts.py)                            | 00:00.203 | 0.0 MB | +-----------------------------------------------------------------------------------------------+-----------+--------+ | plot_extended_tofts (docs/examples/tissue/plot_extended_tofts.py) | 00:00.198 | 0.0 MB | +-----------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/tissue/plot_extended_tofts/","title":"The Extended Tofts model","text":"<p>Note</p> <p>Click here to download the full example code</p> <p>==================== The Extended Tofts model ====================</p> <p>Simulating tissue concentrations from extended Tofts model with different settings.</p> <pre><code>import matplotlib.pyplot as plt\n</code></pre> <p>Import necessary packages</p> <pre><code>import numpy as np\nimport osipi\n</code></pre> <p>Generate Parker AIF with default settings.</p> <pre><code># Define time points in units of seconds - in this case we use a time\n# resolution of 1 sec and a total duration of 6 minutes.\nt = np.arange(0, 6 * 60, 1)\n\n# Create an AIF with default settings\nca = osipi.aif_parker(t)\n</code></pre> <p>Plot the tissue concentrations for an extracellular volume fraction of 0.2 and 3 different plasma volumes of 0.05, 0.2 and 0.6</p> <pre><code>Ktrans = 0.2  # in units of 1/min\nve = 0.2  # volume fraction between 0 and 1\nvp = [0.05, 0.2, 0.6]  # volume fraction between 0 and 1\nct = osipi.extended_tofts(t, ca, Ktrans, ve, vp[0])\nplt.plot(t, ct, \"b-\", label=f\"vp = {vp[0]}\")\nct = osipi.extended_tofts(t, ca, Ktrans, ve, vp[1])\nplt.plot(t, ct, \"g-\", label=f\"vp = {vp[1]}\")\nct = osipi.extended_tofts(t, ca, Ktrans, ve, vp[2])\nplt.plot(t, ct, \"m-\", label=f\"vp = {vp[2]}\")\nplt.xlabel(\"Time (sec)\")\nplt.ylabel(\"Tissue concentration (mM)\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Comparing different discretization methods for an extracellular volume fraction of 0.2, Ktrans of 0.2 /min and vp of 0.05</p> <pre><code>ct = osipi.extended_tofts(t, ca, Ktrans, ve, vp[0])  # Defaults to Convolution\nplt.plot(t, ct, \"b-\", label=\"Convolution\")\nct = osipi.extended_tofts(t, ca, Ktrans, ve, vp[0], discretization_method=\"exp\")\nplt.plot(t, ct, \"g-\", label=\"Exponential Convolution\")\nplt.title(f\"Ktrans = {Ktrans} /min\")\nplt.xlabel(\"Time (sec)\")\nplt.ylabel(\"Tissue concentration (mM)\")\nplt.legend()\nplt.show()\n\n# Choose the last image as a thumbnail for the gallery\n# sphinx_gallery_thumbnail_number = -1\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.198 seconds)</p> <p> Download Python source code: plot_extended_tofts.py</p> <p> Download Jupyter notebook: plot_extended_tofts.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/tissue/plot_tofts/","title":"The Tofts model","text":"<p>Note</p> <p>Click here to download the full example code</p> <p>==================== The Tofts model ====================</p> <p>Simulating tissue concentrations from Tofts model with different settings.</p> <pre><code>import matplotlib.pyplot as plt\n</code></pre> <p>Import necessary packages</p> <pre><code>import numpy as np\nimport osipi\n</code></pre> <p>Generate Parker AIF with default settings.</p> <pre><code># Define time points in units of seconds - in this case we use a time\n# resolution of 1 sec and a total duration of 6 minutes.\nt = np.arange(0, 6 * 60, 1)\n\n# Create an AIF with default settings\nca = osipi.aif_parker(t)\n</code></pre> <p>Plot the tissue concentrations for an extracellular volume fraction of 0.2 and 3 different transfer rate constants of 0.05, 0.2 and 0.6 /min</p> <pre><code>Ktrans = [0.05, 0.2, 0.6]  # in units of 1/min\nve = 0.2  # volume fraction between 0 and 1\nct = osipi.tofts(t, ca, Ktrans=Ktrans[0], ve=ve)\nplt.plot(t, ct, \"b-\", label=f\"Ktrans = {Ktrans[0]} /min\")\nct = osipi.tofts(t, ca, Ktrans[1], ve)\nplt.plot(t, ct, \"g-\", label=f\"Ktrans = {Ktrans[1]} /min\")\nct = osipi.tofts(t, ca, Ktrans[2], ve)\nplt.plot(t, ct, \"m-\", label=f\"Ktrans = {Ktrans[2]} /min\")\nplt.xlabel(\"Time (sec)\")\nplt.ylabel(\"Tissue concentration (mM)\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Comparing different discretization methods for an extracellular volume fraction of 0.2 and Ktrans of 0.2 /min</p> <pre><code>ct = osipi.tofts(t, ca, Ktrans=Ktrans[1], ve=ve)  # Defaults to Convolution\nplt.plot(t, ct, \"b-\", label=\"Convolution\")\nct = osipi.tofts(t, ca, Ktrans=Ktrans[1], ve=ve, discretization_method=\"exp\")\nplt.plot(t, ct, \"g-\", label=\"Exponential Convolution\")\nplt.title(f\"Ktrans = {Ktrans[1]} /min\")\nplt.xlabel(\"Time (sec)\")\nplt.ylabel(\"Tissue concentration (mM)\")\nplt.legend()\nplt.show()\n\n# Choose the last image as a thumbnail for the gallery\n# sphinx_gallery_thumbnail_number = -1\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.203 seconds)</p> <p> Download Python source code: plot_tofts.py</p> <p> Download Jupyter notebook: plot_tofts.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"references/","title":"Reference","text":"<p>This reference manual details all functions included in <code>osipi</code>, describing what they are and what they do. Documentation of individual functions contains self-contained example code that demonstrates basic usage of the function.</p> <p>The <code>osipi</code> package currently only includes methods for the dynamic contrast (DC) approach to perfusion MRI (DC-MRI, a unifying term for the separate fields DCE-MRI and DSC-MRI). In particular arterial spin labelling (ASL) solutions are not currently included, but may be added in the future.</p> <p>This reference guide, like the <code>osipi</code> package itself, adheres closely to the structure and language of the OSIPI Lexicon.</p> <p>Warning</p> <p><code>osipi</code> is in development and this reference guide currently contains mainly empty placeholder entries.</p>"},{"location":"references/models/","title":"Models Overview","text":"<ul> <li>aif_parker</li> <li>aif_georgiou</li> <li>aif_weinmann</li> <li>tofts</li> <li>extended_tofts</li> </ul>"},{"location":"references/models/aif_models/","title":"AIF models","text":"<ul> <li>aif_parker</li> <li>aif_georgiou</li> <li>aif_weinmann</li> </ul>"},{"location":"references/models/aif_models/aif_georgiou/","title":"osipi.aif_georgiou","text":"<p>AIF model as defined by Georgiou et al.</p> Note <p>This function is not yet implemented. If you are implementing it yourself please consider submitting a code contribution to OSIPI, so nobody ever has to write this function again!</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>NDArray[floating]</code> <p>array of time points in units of sec. [OSIPI code Q.GE1.004]</p> required <code>BAT</code> <code>floating</code> <p>Time in seconds before the bolus arrives. Defaults to 0sec. [OSIPI code Q.BA1.001]</p> <code>0.0</code> <p>Returns:</p> Type Description <code>NDArray[floating]</code> <p>NDArray[np.floating]: Concentrations in mM for each time point in t.</p> See Also <p><code>aif_parker</code> <code>aif_weinmann</code></p> References <ul> <li>Lexicon url:     https://osipi.github.io/OSIPI_CAPLEX/perfusionModels/#arterial-input-function-models</li> <li>Lexicon code: M.IC2.002</li> <li>OSIPI name: Georgiou AIF model</li> <li>Adapted from contribution by: TBC</li> </ul> <pre><code>Create an array of time points covering 6min in steps of 1sec,\ncalculate the Georgiou AIF at these time points and plot the results.\n\nImport packages:\n\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import osipi\n\nCalculate AIF and plot\n\n&gt;&gt;&gt; t = np.arange(0, 6 * 60, 0.1)\n&gt;&gt;&gt; ca = osipi.aif_georgiou(t)\n&gt;&gt;&gt; plt.plot(t, ca)\n&gt;&gt;&gt; plt.show()\n</code></pre> Source code in <code>src/osipi/_aif.py</code> <pre><code>def aif_georgiou(t: NDArray[np.floating], BAT: np.floating = 0.0) -&gt; NDArray[np.floating]:\n    \"\"\"AIF model as defined by Georgiou et al.\n\n    Note:\n        This function is not yet implemented.\n        If you are implementing it yourself please consider submitting a code contribution to OSIPI,\n        so nobody ever has to write this function again!\n\n    Args:\n        t (NDArray[np.floating]): array of time points in units of sec. [OSIPI code Q.GE1.004]\n        BAT (np.floating, optional):\n            Time in seconds before the bolus arrives. Defaults to 0sec. [OSIPI code Q.BA1.001]\n\n    Returns:\n        NDArray[np.floating]: Concentrations in mM for each time point in t.\n\n    See Also:\n        `aif_parker`\n        `aif_weinmann`\n\n    References:\n        - Lexicon url:\n            https://osipi.github.io/OSIPI_CAPLEX/perfusionModels/#arterial-input-function-models\n        - Lexicon code: M.IC2.002\n        - OSIPI name: Georgiou AIF model\n        - Adapted from contribution by: TBC\n\n    Example:\n\n        Create an array of time points covering 6min in steps of 1sec,\n        calculate the Georgiou AIF at these time points and plot the results.\n\n        Import packages:\n\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import osipi\n\n        Calculate AIF and plot\n\n        &gt;&gt;&gt; t = np.arange(0, 6 * 60, 0.1)\n        &gt;&gt;&gt; ca = osipi.aif_georgiou(t)\n        &gt;&gt;&gt; plt.plot(t, ca)\n        &gt;&gt;&gt; plt.show()\n\n    \"\"\"\n\n    msg = \"This function is not yet implemented \\n\"\n    msg += (\n        \"If you implement it yourself, please consider submitting it\"\n        \" as an OSIPI code contribution\"\n    )\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/models/aif_models/aif_parker/","title":"osipi.aif_parker","text":"<p>AIF model as defined by Parker et al (2005)</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>NDArray[floating]</code> <p>array of time points in units of sec. [OSIPI code Q.GE1.004]</p> required <code>BAT</code> <code>floating</code> <p>Time in seconds before the bolus arrives. Defaults to 0. [OSIPI code Q.BA1.001]</p> <code>0.0</code> <code>Hct</code> <code>floating</code> <p>Hematocrit. Defaults to 0.0. [OSIPI code Q.PH1.012]</p> <code>0.0</code> <p>Returns:</p> Type Description <code>NDArray[floating]</code> <p>NDArray[np.floating]: Concentrations in mM for each time point in t.</p> See Also <p><code>aif_georgiou</code> <code>aif_weinmann</code></p> References <ul> <li>Lexicon url:     https://osipi.github.io/OSIPI_CAPLEX/perfusionModels/#arterial-input-function-models</li> <li>Lexicon code: M.IC2.001</li> <li>OSIPI name: Parker AIF model</li> <li>Adapted from contribution by: MB_QBI_UoManchester_UK</li> </ul> Example <p>Create an array of time points covering 6 min in steps of 1 sec, calculate the Parker AIF at these time points and plot the results.</p> <p>Import packages:</p> <p>import matplotlib.pyplot as plt import osipi</p> <p>Calculate AIF and plot</p> <p>t = np.arange(0, 6 * 60, 1) ca = osipi.aif_parker(t) plt.plot(t, ca) plt.show()</p> Source code in <code>src/osipi/_aif.py</code> <pre><code>def aif_parker(\n    t: NDArray[np.floating], BAT: np.floating = 0.0, Hct: np.floating = 0.0\n) -&gt; NDArray[np.floating]:\n    \"\"\"AIF model as defined by Parker et al (2005)\n\n    Args:\n        t (NDArray[np.floating]): array of time points in units of sec. [OSIPI code Q.GE1.004]\n        BAT (np.floating, optional):\n            Time in seconds before the bolus arrives. Defaults to 0. [OSIPI code Q.BA1.001]\n        Hct (np.floating, optional):\n            Hematocrit. Defaults to 0.0. [OSIPI code Q.PH1.012]\n\n    Returns:\n        NDArray[np.floating]: Concentrations in mM for each time point in t.\n\n    See Also:\n        `aif_georgiou`\n        `aif_weinmann`\n\n    References:\n        - Lexicon url:\n            https://osipi.github.io/OSIPI_CAPLEX/perfusionModels/#arterial-input-function-models\n        - Lexicon code: M.IC2.001\n        - OSIPI name: Parker AIF model\n        - Adapted from contribution by: MB_QBI_UoManchester_UK\n\n    Example:\n        Create an array of time points covering 6 min in steps of 1 sec,\n        calculate the Parker AIF at these time points and plot the results.\n\n        Import packages:\n\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import osipi\n\n        Calculate AIF and plot\n\n        &gt;&gt;&gt; t = np.arange(0, 6 * 60, 1)\n        &gt;&gt;&gt; ca = osipi.aif_parker(t)\n        &gt;&gt;&gt; plt.plot(t, ca)\n        &gt;&gt;&gt; plt.show()\n\n    \"\"\"\n    # Convert from OSIPI units (sec) to units used internally (mins)\n    t_min = t / 60\n    bat_min = BAT / 60\n\n    t_offset = t_min - bat_min\n\n    # A1/(SD1*sqrt(2*PI)) * exp(-(t_offset-m1)^2/(2*var1))\n    # A1 = 0.833, SD1 = 0.055, m1 = 0.171\n    gaussian1 = 5.73258 * np.exp(\n        -1.0 * (t_offset - 0.17046) * (t_offset - 0.17046) / (2.0 * 0.0563 * 0.0563)\n    )\n\n    # A2/(SD2*sqrt(2*PI)) * exp(-(t_offset-m2)^2/(2*var2))\n    # A2 = 0.336, SD2 = 0.134, m2 = 0.364\n    gaussian2 = 0.997356 * np.exp(\n        -1.0 * (t_offset - 0.365) * (t_offset - 0.365) / (2.0 * 0.132 * 0.132)\n    )\n    # alpha*exp(-beta*t_offset) / (1+exp(-s(t_offset-tau)))\n    # alpha = 1.064, beta = 0.166, s = 37.772, tau = 0.482\n    sigmoid = 1.050 * np.exp(-0.1685 * t_offset) / (1.0 + np.exp(-38.078 * (t_offset - 0.483)))\n\n    pop_aif = (gaussian1 + gaussian2 + sigmoid) / (1.0 - Hct)\n\n    return pop_aif\n</code></pre>"},{"location":"references/models/aif_models/aif_parker/#example-using-osipiaif_parker","title":"Example using <code>osipi.aif_parker</code>","text":"<p> The Parker AIF - a play with variables </p>"},{"location":"references/models/aif_models/aif_weinmann/","title":"osipi.aif_weinmann","text":"<p>AIF model as defined by Weinmann et al.</p> Note <p>This function is not yet implemented. If you are implementing it yourself please consider submitting a code contribution to OSIPI, so nobody ever has to write this function again!</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>NDArray[floating]</code> <p>array of time points in units of sec. [OSIPI code Q.GE1.004]</p> required <code>BAT</code> <code>floating</code> <p>Time in seconds before the bolus arrives. Defaults to 0sec. [OSIPI code Q.BA1.001]</p> <code>0.0</code> <p>Returns:</p> Type Description <code>NDArray[floating]</code> <p>NDArray[np.floating]: Concentrations in mM for each time point in t.</p> See Also <p><code>aif_parker</code> <code>aif_georgiou</code></p> References <ul> <li>Lexicon url:     https://osipi.github.io/OSIPI_CAPLEX/perfusionModels/#arterial-input-function-models</li> <li>Lexicon code: M.IC2.003</li> <li>OSIPI name: Weinmann AIF model</li> <li>Adapted from contribution by: TBC</li> </ul> <pre><code>Create an array of time points covering 6min in steps of 1sec,\ncalculate the Weinmann AIF at these time points and plot the results.\n\nImport packages:\n\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import osipi\n\nCalculate AIF and plot\n\n&gt;&gt;&gt; t = np.arange(0, 6 * 60, 0.1)\n&gt;&gt;&gt; ca = osipi.aif_weinmann(t)\n&gt;&gt;&gt; plt.plot(t, ca)\n</code></pre> Source code in <code>src/osipi/_aif.py</code> <pre><code>def aif_weinmann(t: NDArray[np.floating], BAT: np.floating = 0.0) -&gt; NDArray[np.floating]:\n    \"\"\"AIF model as defined by Weinmann et al.\n\n    Note:\n        This function is not yet implemented.\n        If you are implementing it yourself please consider submitting a code contribution to OSIPI,\n        so nobody ever has to write this function again!\n\n    Args:\n        t (NDArray[np.floating]): array of time points in units of sec. [OSIPI code Q.GE1.004]\n        BAT (np.floating, optional):\n            Time in seconds before the bolus arrives. Defaults to 0sec. [OSIPI code Q.BA1.001]\n\n    Returns:\n        NDArray[np.floating]: Concentrations in mM for each time point in t.\n\n    See Also:\n        `aif_parker`\n        `aif_georgiou`\n\n    References:\n        - Lexicon url:\n            https://osipi.github.io/OSIPI_CAPLEX/perfusionModels/#arterial-input-function-models\n        - Lexicon code: M.IC2.003\n        - OSIPI name: Weinmann AIF model\n        - Adapted from contribution by: TBC\n\n    Example:\n\n        Create an array of time points covering 6min in steps of 1sec,\n        calculate the Weinmann AIF at these time points and plot the results.\n\n        Import packages:\n\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import osipi\n\n        Calculate AIF and plot\n\n        &gt;&gt;&gt; t = np.arange(0, 6 * 60, 0.1)\n        &gt;&gt;&gt; ca = osipi.aif_weinmann(t)\n        &gt;&gt;&gt; plt.plot(t, ca)\n\n    \"\"\"\n\n    msg = \"This function is not yet implemented \\n\"\n    msg += (\n        \"If you implement it yourself, please consider submitting it\"\n        \" as an OSIPI code contribution\"\n    )\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"references/models/tissue_models/","title":"Index","text":"<ul> <li>tofts</li> <li>extended_tofts</li> </ul>"},{"location":"references/models/tissue_models/extended_tofts/","title":"osipi.extended_tofts","text":"<p>Extended tofts model as defined by Tofts (1997)</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>NDArray[floating]</code> <p>array of time points in units of sec. [OSIPI code Q.GE1.004]</p> required <code>ca</code> <code>NDArray[floating]</code> <p>Arterial concentrations in mM for each time point in t. [OSIPI code Q.IC1.001]</p> required <code>Ktrans</code> <code>floating</code> <p>Volume transfer constant in units of 1/min. [OSIPI code Q.PH1.008]</p> required <code>ve</code> <code>floating</code> <p>Relative volume fraction of the extracellular extravascular compartment (e). [OSIPI code Q.PH1.001.[e]]</p> required <code>vp</code> <code>floating</code> <p>Relative volyme fraction of the plasma compartment (p). [OSIPI code Q.PH1.001.[p]]</p> required <code>Ta</code> <code>floating</code> <p>Arterial delay time, i.e., difference in onset time between tissue curve and AIF in units of sec. Defaults to 30 seconds. [OSIPI code Q.PH1.007]</p> <code>30.0</code> <code>discretization_method</code> <code>str</code> <p>Defines the discretization method. Options include</p> <p>\u2013 'conv': Numerical convolution (default) [OSIPI code G.DI1.001]</p> <p>\u2013 'exp': Exponential convolution [OSIPI code G.DI1.006]</p> <code>'conv'</code> <p>Returns:</p> Type Description <code>NDArray[floating]</code> <p>NDArray[np.floating]: Tissue concentrations in mM for each time point in t.</p> See Also <p><code>tofts</code></p> References <ul> <li>Lexicon url: https://osipi.github.io/OSIPI_CAPLEX/perfusionModels/#indicator-kinetic-models</li> <li>Lexicon code: M.IC1.005</li> <li>OSIPI name: Extended Tofts Model</li> <li>Adapted from contributions by: LEK_UoEdinburgh_UK, ST_USyd_AUS, MJT_UoEdinburgh_UK</li> </ul> <pre><code>Create an array of time points covering 6 min in steps of 1 sec,\ncalculate the Parker AIF at these time points, calculate tissue concentrations\nusing the Extended Tofts model and plot the results.\n\nImport packages:\n\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import osipi\n\nCalculate AIF\n\n&gt;&gt;&gt; t = np.arange(0, 6 * 60, 0.1)\n&gt;&gt;&gt; ca = osipi.aif_parker(t)\n\nCalculate tissue concentrations and plot\n\n&gt;&gt;&gt; Ktrans = 0.6  # in units of 1/min\n&gt;&gt;&gt; ve = 0.2  # takes values from 0 to 1\n&gt;&gt;&gt; vp = 0.3  # takes values from 0 to 1\n&gt;&gt;&gt; ct = osipi.extended_tofts(t, ca, Ktrans, ve, vp)\n&gt;&gt;&gt; plt.plot(t, ca, \"r\", t, ct, \"b\")\n</code></pre> Source code in <code>src/osipi/_tissue.py</code> <pre><code>def extended_tofts(\n    t: NDArray[np.floating],\n    ca: NDArray[np.floating],\n    Ktrans: np.floating,\n    ve: np.floating,\n    vp: np.floating,\n    Ta: np.floating = 30.0,\n    discretization_method: str = \"conv\",\n) -&gt; NDArray[np.floating]:\n    \"\"\"Extended tofts model as defined by Tofts (1997)\n\n    Args:\n        t (NDArray[np.floating]):\n            array of time points in units of sec. [OSIPI code Q.GE1.004]\n        ca (NDArray[np.floating]):\n            Arterial concentrations in mM for each time point in t. [OSIPI code Q.IC1.001]\n        Ktrans (np.floating):\n            Volume transfer constant in units of 1/min. [OSIPI code Q.PH1.008]\n        ve (np.floating):\n            Relative volume fraction of the extracellular\n            extravascular compartment (e). [OSIPI code Q.PH1.001.[e]]\n        vp (np.floating):\n            Relative volyme fraction of the plasma compartment (p). [OSIPI code Q.PH1.001.[p]]\n        Ta (np.floating, optional):\n            Arterial delay time, i.e., difference in onset time\n            between tissue curve and AIF in units of sec.\n            Defaults to 30 seconds. [OSIPI code Q.PH1.007]\n        discretization_method (str, optional):\n            Defines the discretization method. Options include\n\n            \u2013 'conv': Numerical convolution (default) [OSIPI code G.DI1.001]\n\n            \u2013 'exp': Exponential convolution [OSIPI code G.DI1.006]\n\n\n    Returns:\n        NDArray[np.floating]: Tissue concentrations in mM for each time point in t.\n\n    See Also:\n        `tofts`\n\n    References:\n        - Lexicon url: https://osipi.github.io/OSIPI_CAPLEX/perfusionModels/#indicator-kinetic-models\n        - Lexicon code: M.IC1.005\n        - OSIPI name: Extended Tofts Model\n        - Adapted from contributions by: LEK_UoEdinburgh_UK, ST_USyd_AUS, MJT_UoEdinburgh_UK\n\n    Example:\n\n        Create an array of time points covering 6 min in steps of 1 sec,\n        calculate the Parker AIF at these time points, calculate tissue concentrations\n        using the Extended Tofts model and plot the results.\n\n        Import packages:\n\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import osipi\n\n        Calculate AIF\n\n        &gt;&gt;&gt; t = np.arange(0, 6 * 60, 0.1)\n        &gt;&gt;&gt; ca = osipi.aif_parker(t)\n\n        Calculate tissue concentrations and plot\n\n        &gt;&gt;&gt; Ktrans = 0.6  # in units of 1/min\n        &gt;&gt;&gt; ve = 0.2  # takes values from 0 to 1\n        &gt;&gt;&gt; vp = 0.3  # takes values from 0 to 1\n        &gt;&gt;&gt; ct = osipi.extended_tofts(t, ca, Ktrans, ve, vp)\n        &gt;&gt;&gt; plt.plot(t, ca, \"r\", t, ct, \"b\")\n\n    \"\"\"\n\n    if not np.allclose(np.diff(t), np.diff(t)[0]):\n        warnings.warn(\n            (\"Non-uniform time spacing detected. Time array may be\" \" resampled.\"),\n            stacklevel=2,\n        )\n\n    if Ktrans &lt;= 0 or ve &lt;= 0:\n        ct = vp * ca\n\n    else:\n        # Convert units\n        Ktrans = Ktrans / 60  # from 1/min to 1/sec\n\n        if discretization_method == \"exp\":  # Use exponential convolution\n            # Shift the AIF by the arterial delay time (if not zero)\n            if Ta != 0:\n                f = interp1d(\n                    t,\n                    ca,\n                    kind=\"linear\",\n                    bounds_error=False,\n                    fill_value=0,\n                )\n                ca = (t &gt; Ta) * f(t - Ta)\n\n            Tc = ve / Ktrans\n            # expconv calculates convolution of ca and\n            # (1/Tc)exp(-t/Tc), add vp*ca term for extended model\n            ct = (vp * ca) + ve * exp_conv(Tc, t, ca)\n\n        else:  # Use convolution by default\n            # Calculate the impulse response function\n            kep = Ktrans / ve\n            imp = Ktrans * np.exp(-1 * kep * t)\n\n            # Shift the AIF by the arterial delay time (if not zero)\n            if Ta != 0:\n                f = interp1d(\n                    t,\n                    ca,\n                    kind=\"linear\",\n                    bounds_error=False,\n                    fill_value=0,\n                )\n                ca = (t &gt; Ta) * f(t - Ta)\n\n            # Check if time data grid is uniformly spaced\n            if np.allclose(np.diff(t), np.diff(t)[0]):\n                # Convolve impulse response with AIF\n                convolution = np.convolve(ca, imp)\n\n                # Discard unwanted points, make sure time spacing is\n                # correct and add vp*ca term for extended model\n                ct = convolution[0 : len(t)] * t[1] + (vp * ca)\n            else:\n                # Resample at the smallest spacing\n                dt = np.min(np.diff(t))\n                t_resampled = np.linspace(t[0], t[-1], int((t[-1] - t[0]) / dt))\n                ca_func = interp1d(\n                    t,\n                    ca,\n                    kind=\"quadratic\",\n                    bounds_error=False,\n                    fill_value=0,\n                )\n                imp_func = interp1d(\n                    t,\n                    imp,\n                    kind=\"quadratic\",\n                    bounds_error=False,\n                    fill_value=0,\n                )\n                ca_resampled = ca_func(t_resampled)\n                imp_resampled = imp_func(t_resampled)\n                # Convolve impulse response with AIF\n                convolution = np.convolve(ca_resampled, imp_resampled)\n\n                # Discard unwanted points, make sure time spacing is\n                # correct and add vp*ca term for extended model\n                ct_resampled = convolution[0 : len(t_resampled)] * t_resampled[1] + (\n                    vp * ca_resampled\n                )\n\n                # Restore time grid spacing\n                ct_func = interp1d(\n                    t_resampled,\n                    ct_resampled,\n                    kind=\"quadratic\",\n                    bounds_error=False,\n                    fill_value=0,\n                )\n                ct = ct_func(t)\n\n    return ct\n</code></pre>"},{"location":"references/models/tissue_models/extended_tofts/#example-using-osipiextended_tofts","title":"Example using <code>osipi.extended_tofts</code>","text":"<p> The Extended Tofts model </p>"},{"location":"references/models/tissue_models/tofts/","title":"osipi.tofts","text":"<p>Tofts model as defined by Tofts and Kermode (1991)</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>NDArray[floating]</code> <p>array of time points in units of sec. [OSIPI code Q.GE1.004]</p> required <code>ca</code> <code>NDArray[floating]</code> <p>Arterial concentrations in mM for each time point in t. [OSIPI code Q.IC1.001]</p> required <code>Ktrans</code> <code>floating</code> <p>Volume transfer constant in units of 1/min. [OSIPI code Q.PH1.008]</p> required <code>ve</code> <code>floating</code> <p>Relative volume fraction of the extracellular extravascular compartment (e). [OSIPI code Q.PH1.001.[e]]</p> required <code>Ta</code> <code>floating</code> <p>Arterial delay time, i.e., difference in onset time between tissue curve and AIF in units of sec. Defaults to 30 seconds. [OSIPI code Q.PH1.007]</p> <code>30.0</code> <code>discretization_method</code> <code>str</code> <p>Defines the discretization method. Options include</p> <p>\u2013 'conv': Numerical convolution (default) [OSIPI code G.DI1.001]</p> <p>\u2013 'exp': Exponential convolution [OSIPI code G.DI1.006]</p> <code>'conv'</code> <p>Returns:</p> Type Description <code>NDArray[floating]</code> <p>NDArray[np.floating]: Tissue concentrations in mM for each time point in t.</p> See Also <p><code>extended_tofts</code></p> References <ul> <li>Lexicon url:     https://osipi.github.io/OSIPI_CAPLEX/perfusionModels/#indicator-kinetic-models</li> <li>Lexicon code: M.IC1.004</li> <li>OSIPI name: Tofts Model</li> <li>Adapted from contributions by: LEK_UoEdinburgh_UK, ST_USyd_AUS, MJT_UoEdinburgh_UK</li> </ul> <pre><code>Create an array of time points covering 6 min in steps of 1 sec,\ncalculate the Parker AIF at these time points, calculate tissue concentrations\nusing the Tofts model and plot the results.\n\nImport packages:\n\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import osipi\n&gt;&gt;&gt; import numpy\n\nCalculate AIF:\n\n&gt;&gt;&gt; t = np.arange(0, 6 * 60, 1)\n&gt;&gt;&gt; ca = osipi.aif_parker(t)\n\nCalculate tissue concentrations and plot:\n\n&gt;&gt;&gt; Ktrans = 0.6  # in units of 1/min\n&gt;&gt;&gt; ve = 0.2  # takes values from 0 to 1\n&gt;&gt;&gt; ct = osipi.tofts(t, ca, Ktrans, ve)\n&gt;&gt;&gt; plt.plot(t, ca, \"r\", t, ct, \"b\")\n</code></pre> Source code in <code>src/osipi/_tissue.py</code> <pre><code>def tofts(\n    t: NDArray[np.floating],\n    ca: NDArray[np.floating],\n    Ktrans: np.floating,\n    ve: np.floating,\n    Ta: np.floating = 30.0,\n    discretization_method: str = \"conv\",\n) -&gt; NDArray[np.floating]:\n    \"\"\"Tofts model as defined by Tofts and Kermode (1991)\n\n    Args:\n        t (NDArray[np.floating]): array of time points in units of sec. [OSIPI code Q.GE1.004]\n        ca (NDArray[np.floating]):\n            Arterial concentrations in mM for each time point in t. [OSIPI code Q.IC1.001]\n        Ktrans (np.floating):\n            Volume transfer constant in units of 1/min. [OSIPI code Q.PH1.008]\n        ve (np.floating):\n            Relative volume fraction of the extracellular\n            extravascular compartment (e). [OSIPI code Q.PH1.001.[e]]\n        Ta (np.floating, optional):\n            Arterial delay time,\n            i.e., difference in onset time between tissue curve and AIF in units of sec. Defaults to 30 seconds. [OSIPI code Q.PH1.007]\n        discretization_method (str, optional): Defines the discretization method. Options include\n\n            \u2013 'conv': Numerical convolution (default) [OSIPI code G.DI1.001]\n\n            \u2013 'exp': Exponential convolution [OSIPI code G.DI1.006]\n\n\n    Returns:\n        NDArray[np.floating]: Tissue concentrations in mM for each time point in t.\n\n    See Also:\n        `extended_tofts`\n\n    References:\n        - Lexicon url:\n            https://osipi.github.io/OSIPI_CAPLEX/perfusionModels/#indicator-kinetic-models\n        - Lexicon code: M.IC1.004\n        - OSIPI name: Tofts Model\n        - Adapted from contributions by: LEK_UoEdinburgh_UK, ST_USyd_AUS, MJT_UoEdinburgh_UK\n\n    Example:\n\n        Create an array of time points covering 6 min in steps of 1 sec,\n        calculate the Parker AIF at these time points, calculate tissue concentrations\n        using the Tofts model and plot the results.\n\n        Import packages:\n\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import osipi\n        &gt;&gt;&gt; import numpy\n\n        Calculate AIF:\n\n        &gt;&gt;&gt; t = np.arange(0, 6 * 60, 1)\n        &gt;&gt;&gt; ca = osipi.aif_parker(t)\n\n        Calculate tissue concentrations and plot:\n\n        &gt;&gt;&gt; Ktrans = 0.6  # in units of 1/min\n        &gt;&gt;&gt; ve = 0.2  # takes values from 0 to 1\n        &gt;&gt;&gt; ct = osipi.tofts(t, ca, Ktrans, ve)\n        &gt;&gt;&gt; plt.plot(t, ca, \"r\", t, ct, \"b\")\n\n    \"\"\"\n    if not np.allclose(np.diff(t), np.diff(t)[0]):\n        warnings.warn(\n            (\"Non-uniform time spacing detected. Time array may be\" \" resampled.\"),\n            stacklevel=2,\n        )\n\n    if Ktrans &lt;= 0 or ve &lt;= 0:\n        ct = 0 * ca\n\n    else:\n        # Convert units\n        Ktrans = Ktrans / 60  # from 1/min to 1/sec\n\n        if discretization_method == \"exp\":  # Use exponential convolution\n            # Shift the AIF by the arterial delay time (if not zero)\n            if Ta != 0:\n                f = interp1d(\n                    t,\n                    ca,\n                    kind=\"linear\",\n                    bounds_error=False,\n                    fill_value=0,\n                )\n                ca = (t &gt; Ta) * f(t - Ta)\n\n            Tc = ve / Ktrans\n            ct = ve * exp_conv(Tc, t, ca)\n\n        else:  # Use convolution by default\n            # Calculate the impulse response function\n            kep = Ktrans / ve\n            imp = Ktrans * np.exp(-1 * kep * t)\n\n            # Shift the AIF by the arterial delay time (if not zero)\n            if Ta != 0:\n                f = interp1d(\n                    t,\n                    ca,\n                    kind=\"linear\",\n                    bounds_error=False,\n                    fill_value=0,\n                )\n                ca = (t &gt; Ta) * f(t - Ta)\n\n            # Check if time data grid is uniformly spaced\n            if np.allclose(np.diff(t), np.diff(t)[0]):\n                # Convolve impulse response with AIF\n                convolution = np.convolve(ca, imp)\n\n                # Discard unwanted points and make sure time spacing\n                # is correct\n                ct = convolution[0 : len(t)] * t[1]\n            else:\n                # Resample at the smallest spacing\n                dt = np.min(np.diff(t))\n                t_resampled = np.linspace(t[0], t[-1], int((t[-1] - t[0]) / dt))\n                ca_func = interp1d(\n                    t,\n                    ca,\n                    kind=\"quadratic\",\n                    bounds_error=False,\n                    fill_value=0,\n                )\n                imp_func = interp1d(\n                    t,\n                    imp,\n                    kind=\"quadratic\",\n                    bounds_error=False,\n                    fill_value=0,\n                )\n                ca_resampled = ca_func(t_resampled)\n                imp_resampled = imp_func(t_resampled)\n                # Convolve impulse response with AIF\n                convolution = np.convolve(ca_resampled, imp_resampled)\n\n                # Discard unwanted points and make sure time spacing\n                # is correct\n                ct_resampled = convolution[0 : len(t_resampled)] * t_resampled[1]\n\n                # Restore time grid spacing\n                ct_func = interp1d(\n                    t_resampled,\n                    ct_resampled,\n                    kind=\"quadratic\",\n                    bounds_error=False,\n                    fill_value=0,\n                )\n                ct = ct_func(t)\n\n    return ct\n</code></pre>"},{"location":"references/models/tissue_models/tofts/#example-using-osipitofts","title":"Example using <code>osipi.tofts</code>","text":"<p> The Tofts model </p>"},{"location":"user-guide/","title":"User Guide","text":"<p>Welcome to the User Guide section.</p>"},{"location":"user-guide/#contents","title":"Contents","text":"<ol> <li>Installing osipi</li> <li>Simulating data<ul> <li>Generating an AIF</li> <li>Generating a tissue concentration</li> <li>Generating an MRI signal</li> <li>Adding measurement error</li> </ul> </li> <li>Fitting data<ul> <li>Signal to relaxation time</li> <li>Relaxation time to concentration</li> <li>Concentration to tissue parameters</li> <li>All in one go: signal to tissue parameters</li> </ul> </li> </ol>"},{"location":"user-guide/fit_tissue/","title":"Fit","text":""},{"location":"user-guide/fit_tissue/#signal-to-relaxation-time","title":"Signal to relaxation time:","text":"<p>Coming Soon</p> <p>This section is under development and will be available soon.</p>"},{"location":"user-guide/fit_tissue/#relaxation-time-to-concentration","title":"Relaxation time to concentration:","text":"<p>Coming Soon</p> <p>This section is under development and will be available soon.</p>"},{"location":"user-guide/fit_tissue/#concentration-to-tissue-parameters","title":"Concentration to tissue parameters:","text":"<p>Coming Soon</p> <p>This section is under development and will be available soon.</p>"},{"location":"user-guide/fit_tissue/#all-in-one-go-signal-to-tissue-parameters","title":"All in one go: signal to tissue parameters:","text":"<p>Coming Soon</p> <p>This section is under development and will be available soon.</p>"},{"location":"user-guide/fitting/","title":"Overview","text":"<ul> <li>Signal to relaxation time</li> <li>Relaxation time to concentration</li> <li>Concentration to tissue parameters</li> <li>All in one go: signal to tissue parameters</li> </ul>"},{"location":"user-guide/gen_aif/","title":"Simulate","text":""},{"location":"user-guide/gen_aif/#generate-an-aif-and-plot-it","title":"Generate an AIF and plot it:","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport osipi\n\nt = np.arange(0, 6*60, 1)\nca = osipi.aif_parker(t)\nplt.plot(t, ca)\nplt.show()\n</code></pre>"},{"location":"user-guide/gen_aif/#generating-a-tissue-concentration","title":"Generating a tissue concentration","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport osipi\n\nt = np.arange(0, 6*60, 1)\nca = osipi.aif_parker(t)\nKtrans = 0.6\nve = 0.2\nct = osipi.tofts(t, ca, Ktrans=Ktrans/60, ve=ve)\nplt.plot(t, ct)\nplt.show()\n</code></pre>"},{"location":"user-guide/gen_aif/#generating-an-mri-signal","title":"Generating an MRI signal","text":"<p>Coming Soon</p> <p>This section is under development and will be available soon.</p>"},{"location":"user-guide/gen_aif/#adding-measurement-error","title":"Adding measurement error","text":"<p>Coming Soon</p> <p>This section is under development and will be available soon.</p>"},{"location":"user-guide/install/","title":"Installing osipi","text":""},{"location":"user-guide/install/#step-1-prerequisites","title":"Step 1: Prerequisites","text":"<p>Ensure you have Python installed. You can download it from the official Python website.</p>"},{"location":"user-guide/install/#step-2-install-using-pip","title":"Step 2: Install Using pip","text":"<p>To install the package using <code>pip</code>, open your terminal and run the following command:</p> <pre><code>pip install osipi\n</code></pre>"},{"location":"user-guide/simulate/","title":"Overview","text":"<ul> <li>Generating an AIF</li> <li>Generating a Tissue Concentration</li> <li>Generating an MRI Signal</li> <li>Adding Measurement Error</li> </ul>"}]}